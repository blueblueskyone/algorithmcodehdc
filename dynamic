1、最长回文子串
#动态规划解最长回文,当s[i]=s[j]时，dp[i][j] = dp[i + 1][j - 1]；当s[i]！=s[j]时，dp[i][j] = F
class Solution:
    def longestPalindrome(self, s: str) -> str:

        #最长回文字串
        m=len(s)
        if m<2:
            return s

        max_len = 1
        begin = 0

        dp = [[False] * m for _ in range(m)]

        for i in range(m):
            dp[i][i] = True

        # 先枚举子串长度
        for L in range(2, m + 1):
            # 枚举左边界，左边界的上限设置可以宽松一些
            for i in range(m):
                # 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                j = L + i - 1
                # 如果右边界越界，就可以退出当前循环
                if j >= m:
                    break
                    
                if s[i] != s[j]:
                    dp[i][j] = False 
                else:
                    if j - i < 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i + 1][j - 1]
                if dp[i][j] and j - i + 1 > max_len:
                    max_len = j - i + 1
                    begin = i
        return s[begin:begin + max_len]

#其他解法：
#扩展法，核心思路求出扩展左右对称的位置，注意有两种情况一种情况是奇数对称，另一种情况是偶数对称
复杂度是O(n^2)
class Solution:
    def longestPalindrome(self, s: str) -> str:

        #最长回文字串
        m=len(s)
        if m==0:
            return s
        
        def expand1(s,left,right):
            while left>=0 and right<m and s[left]==s[right]:
                  left=left-1
                  right=right+1
            return left+1,right-1

        end=0
        start=0
        for i in range(m):

            left1,right1=expand1(s,i,i)

            left2,right2=expand1(s,i,i+1)

            if right1-left1>end-start:
                start,end=left1,right1
            if right2-left2>end-start:
                start,end=left2,right2

        return s[start:end+1]

2、无重复字符最长子串
#求最长子串长度，核心思路不断求不重复字符长度，贪心算法记录出最大值
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:


        l=0
        m=len(s)
        i=0
        max1=0
        d=[]
        while i<m:
             if s[i] not in d:
                 d.append(s[i])
                 i=i+1
                 l=len(d)
                 max1=max(max1,l)
             else:
                 while d:
                     if d.pop(0)!=s[i]:
                         continue
                     else:
                         break
                 d.append(s[i])
                 i=i+1
                 l=len(d)
                 max1=max(max1,l)
        
        return max1
